"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const crypto_1 = __importDefault(require("crypto"));
const yaml_1 = require("yaml");
const jose_1 = require("jose");
const YAML_SD_1 = __importDefault(require("../YAML-SD"));
const Parse_1 = __importDefault(require("../lib/Parse"));
const digester = (name = 'sha-256') => {
    if (name !== 'sha-256') {
        throw new Error('hash function not supported');
    }
    return {
        name,
        digest: (json) => __awaiter(void 0, void 0, void 0, function* () {
            return jose_1.base64url.encode(crypto_1.default.createHash("sha256").update(json).digest());
        })
    };
};
const salter = () => __awaiter(void 0, void 0, void 0, function* () {
    return jose_1.base64url.encode(crypto_1.default.randomBytes(16));
});
const getSpec = (path) => {
    const spec = fs_1.default.readFileSync(path, "utf8");
    const doc = YAML_SD_1.default.parseCustomTags(spec);
    return doc;
};
const decodeToken = (jws) => {
    const protectedHeader = (0, jose_1.decodeProtectedHeader)(jws);
    const payload = (0, jose_1.decodeJwt)(jws);
    return { protectedHeader, payload };
};
const decodeIssuanceForm = (sdJwt) => {
    var _a;
    const parsed = Parse_1.default.compact(sdJwt);
    const parsedDecoded = Parse_1.default.compact(sdJwt, { decodeDisclosure: true });
    const saltMap = {};
    (_a = parsed.disclosures) === null || _a === void 0 ? void 0 : _a.forEach((item) => {
        const parsed = JSON.parse(new TextDecoder().decode(jose_1.base64url.decode(item)));
        let withoutSalt = [];
        if (parsed.length === 2) {
            withoutSalt = [parsed[1]];
        }
        else {
            withoutSalt = [parsed[1], parsed[2]];
        }
        const saltKey = jose_1.base64url.encode(JSON.stringify(withoutSalt));
        if (!saltMap[saltKey]) {
            saltMap[saltKey] = parsed[0];
        }
        else {
            if (Array.isArray(saltMap[saltKey])) {
                saltMap[saltKey].push(parsed[0]);
            }
            else {
                saltMap[saltKey] = [saltMap[saltKey]];
                saltMap[saltKey].push(parsed[0]);
            }
        }
    });
    return {
        parsed,
        parsedDecoded,
        decoded: decodeToken(parsed.jwt),
        saltMap,
    };
};
const decodeExpectedIssuance = (path) => {
    const parsedIssuance = fs_1.default.readFileSync(path, "utf8").split("\n").join("");
    return decodeIssuanceForm(parsedIssuance);
};
const getUserClaims = (path) => {
    const user_claims = JSON.parse(fs_1.default.readFileSync(path, "utf8").toString());
    return user_claims;
};
const getSalter = (pathToDoc) => {
    const doc = decodeExpectedIssuance(pathToDoc);
    const salter = (pair) => {
        let withoutSalt;
        if (pair instanceof yaml_1.Pair) {
            withoutSalt = [pair.key.value, JSON.parse(JSON.stringify(pair.value))];
        }
        else if (pair instanceof yaml_1.Scalar) {
            withoutSalt = [JSON.parse(JSON.stringify((0, yaml_1.parse)(pair.value)))];
        }
        else {
            withoutSalt = [JSON.parse(JSON.stringify(pair))];
        }
        const saltKey = jose_1.base64url.encode(JSON.stringify(withoutSalt));
        if (Array.isArray(doc.saltMap[saltKey])) {
            return doc.saltMap[saltKey].shift();
        }
        return doc.saltMap[saltKey];
    };
    return salter;
};
const getExpectedPayload = (pathToPayload) => {
    const expectedPayload = JSON.parse(fs_1.default.readFileSync(pathToPayload, "utf8").toString());
    delete expectedPayload["iss"];
    delete expectedPayload["iat"];
    delete expectedPayload["exp"];
    delete expectedPayload["_sd_alg"];
    return expectedPayload;
};
const api = {
    digester,
    getExpectedPayload,
    getSpec,
    getSalter,
    salter,
    decodeIssuanceForm,
    decodeExpectedIssuance,
    getUserClaims,
};
exports.default = api;
