"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.issuancePayload = void 0;
const jose_1 = require("jose");
const yaml_1 = require("yaml");
const constants_1 = require("./constants");
const disclose_1 = require("./disclose");
const serializeDisclosure_1 = require("./serializeDisclosure");
const walkMap_1 = require("./walkMap");
const updateTarget = (source, sourceItem, index, targetItem) => {
    if (sourceItem instanceof yaml_1.Pair) {
        let foundExistingDisclosure = source.items.find((item) => {
            return item.key.value === '_sd';
        });
        if (!foundExistingDisclosure) {
            const disclosureKeyScalar = new yaml_1.Scalar('_sd');
            const disclosureKeySeq = new yaml_1.YAMLSeq();
            foundExistingDisclosure = new yaml_1.Pair(disclosureKeyScalar, disclosureKeySeq);
            source.items.push(foundExistingDisclosure);
        }
        foundExistingDisclosure.value.items.push(targetItem);
    }
    else {
        source.items[index] = targetItem;
    }
};
const getDisclosureItem = (salt, source, config) => __awaiter(void 0, void 0, void 0, function* () {
    const json = (0, serializeDisclosure_1.serializeDisclosure)(salt, source);
    const encoded = jose_1.base64url.encode(json);
    // spy here...
    const disclosureHash = yield config.digester.digest(encoded);
    config.disclosures[encoded] = disclosureHash;
    const disclosureHashScalar = new yaml_1.Scalar(disclosureHash);
    if (source instanceof yaml_1.Pair) {
        return disclosureHashScalar;
    }
    else {
        const disclosePair = new yaml_1.Pair('...', disclosureHashScalar);
        const discloseElement = new yaml_1.YAMLMap();
        discloseElement.add(disclosePair);
        return discloseElement;
    }
});
const addDisclosure = (source, index, sourceItem, config) => __awaiter(void 0, void 0, void 0, function* () {
    const salt = yield config.salter(sourceItem);
    if (!salt) {
        console.warn(JSON.stringify(sourceItem, null, 2));
        throw new Error('Unhandled salt disclosure...');
    }
    const item = yield getDisclosureItem(salt, sourceItem, config);
    updateTarget(source, sourceItem, index, item);
});
const issuanceWalkMap = (source, config) => __awaiter(void 0, void 0, void 0, function* () {
    const indexList = [];
    for (const index in source.items) {
        const sourcePair = source.items[index];
        if (sourcePair.value instanceof yaml_1.YAMLSeq) {
            yield issuanceWalkList(sourcePair.value, config);
        }
        if (sourcePair.value instanceof yaml_1.YAMLMap) {
            yield issuanceWalkMap(sourcePair.value, config);
        }
        if (sourcePair.key.tag === constants_1.discloseTag) {
            yield addDisclosure(source, index, sourcePair, config);
            indexList.push(parseInt(index, 10));
        }
    }
    (0, disclose_1.redactSource)(source, indexList);
});
const issuanceWalkList = (source, config) => __awaiter(void 0, void 0, void 0, function* () {
    const indexList = [];
    for (const index in source.items) {
        const sourceElement = source.items[index];
        if (sourceElement instanceof yaml_1.YAMLSeq) {
            yield issuanceWalkList(sourceElement, config);
        }
        if (sourceElement instanceof yaml_1.YAMLMap) {
            yield issuanceWalkMap(sourceElement, config);
        }
        if (sourceElement.tag === constants_1.discloseTag) {
            yield addDisclosure(source, index, sourceElement, config);
            // indexList.push(parseInt(index, 10));
        }
    }
    (0, disclose_1.redactSource)(source, indexList);
});
const disclosureSorter = (pair) => {
    if (pair.key && pair.key.value === '_sd') {
        pair.value.items.sort((a, b) => {
            if (a.value >= b.value) {
                return 1;
            }
            else {
                return -1;
            }
        });
    }
};
const preconditionChecker = (pair) => {
    if (pair.key && pair.key.value === '_sd') {
        throw new Error('claims may not contain _sd');
    }
};
const issuancePayload = (doc, config) => __awaiter(void 0, void 0, void 0, function* () {
    (0, walkMap_1.walkMap)(doc, preconditionChecker);
    yield issuanceWalkMap(doc, config);
    (0, walkMap_1.walkMap)(doc, disclosureSorter);
    return JSON.parse(JSON.stringify(doc));
});
exports.issuancePayload = issuancePayload;
