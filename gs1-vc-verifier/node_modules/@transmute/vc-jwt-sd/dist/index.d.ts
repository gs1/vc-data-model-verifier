import verifier from './lib/verifier';
declare const sd: {
    YAML: {
        load: (data: string) => import("yaml").YAMLMap<unknown, unknown>;
        issuancePayload: (doc: any, config: any) => Promise<any>;
        parseCustomTags: (data: string) => import("yaml").Document.Parsed<import("yaml").Alias.Parsed, true> | import("yaml").Document.Parsed<import("yaml").Scalar.Parsed, true> | import("yaml").Document.Parsed<import("yaml").YAMLMap.Parsed<import("yaml").ParsedNode, import("yaml").ParsedNode | null>, true> | import("yaml").Document.Parsed<import("yaml").YAMLSeq.Parsed<import("yaml").ParsedNode>, true>;
        loads: typeof import("yaml").parse;
        dumps: (data: any) => string;
        disclose: (source: string, target: string) => string;
        roughlyEqual: (a: string, b: string) => boolean;
    };
    jwk: {
        format: (jwk: import("./types").PublicKeyJwk | import("./types").PrivateKeyJwk) => import("./types").PublicKeyJwk | import("./types").PrivateKeyJwk;
        getPublicKey: (jwk: any) => import("./types").PublicKeyJwk;
        generate: (alg: string) => Promise<{
            publicKeyJwk: import("./types").PublicKeyJwk | import("./types").PrivateKeyJwk;
            privateKeyJwk: import("./types").PublicKeyJwk | import("./types").PrivateKeyJwk;
        }>;
    };
    jws: {
        signer: (privateKeyJwk: import("./types").PrivateKeyJwk) => Promise<import("./types").Signer>;
        verifier: (publicKeyJwk: import("./types").PublicKeyJwk) => Promise<{
            verify: (jws: string) => Promise<{
                protectedHeader: import("jose").CompactJWSHeaderParameters;
                claimset: any;
            }>;
        }>;
    };
    parse: {
        compact: (jws: string, options?: {
            decodeDisclosure: boolean;
        }) => import("./types").ParsedSdJwt;
        expload: (jws: string, config: any) => Promise<any>;
    };
    key: {
        format: (jwk: import("./types").PublicKeyJwk | import("./types").PrivateKeyJwk) => import("./types").PublicKeyJwk | import("./types").PrivateKeyJwk;
        getPublicKey: (jwk: any) => import("./types").PublicKeyJwk;
        generate: (alg: string) => Promise<{
            publicKeyJwk: import("./types").PublicKeyJwk | import("./types").PrivateKeyJwk;
            privateKeyJwk: import("./types").PublicKeyJwk | import("./types").PrivateKeyJwk;
        }>;
    };
    salter: () => () => Promise<string>;
    digester: (name?: string) => {
        name: string;
        digest: (json: string) => Promise<string>;
    };
    issuer: (options: import("./types").RequestIssuer) => {
        issue: ({ claimset, jwk, kid, iat, exp }: {
            claimset: string;
            jwk?: any;
            kid?: any;
            iat?: string | undefined;
            exp?: string | undefined;
        }) => Promise<string>;
    };
    holder: (options?: import("./types").RequestHolder) => {
        issue: ({ token, disclosure, audience, nonce }: {
            token: string;
            disclosure: string;
            audience?: string | string[] | undefined;
            nonce?: string | undefined;
        }) => Promise<string>;
    };
    verifier: typeof verifier;
};
export * from './types';
export default sd;
