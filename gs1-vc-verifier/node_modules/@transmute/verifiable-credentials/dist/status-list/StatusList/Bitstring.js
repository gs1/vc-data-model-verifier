"use strict";
/*!
 * Copyright (c) 2020-2023 Digital Bazaar, Inc. All rights reserved.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bitstring = void 0;
// Modified for TypeScript by Orie Steele
const pako_1 = require("pako");
const jose_1 = require("jose");
const assert = __importStar(require("./assertions"));
class Bitstring {
    /**
     * Creates a new Bitstring  instance.
     *
     * @param {object} options - The options to use.
     * @param {number} [options.length] - The length of the bitstring in bits;
     *   either this or `buffer` must be given, but not both.
     * @param {Uint8Array} [options.buffer] - The bitstring as a buffer of bytes
     *   where the bytes are always in big endian order (left most byte or most
     *   significant byte in the buffer will be the least significant and lowest
     *   index byte in the bitstring) and where the bit order
     *   is also little endian by default but may be specified as big endian
     *   by passing `leftToRightIndexing: false`; either this parameter or
     *   `length` must be given but not both.
     * @param {boolean} [options.leftToRightIndexing=true] - Whether the bit
     *   order (NOT the byte order, which is *always* first byte in the buffer is
     *   the first byte-index into the bitstring, i.e., left to right) is left to
     *   right or not; the default is left to right, which matches what the byte
     *   order always is and, specifically, means that `0x80` or `0b1000000`
     *   means the first bit index is set in a given byte.
     * @param {boolean} [options.littleEndianBits] - Deprecated; use
     *   `leftToRightIndexing` instead.
     */
    constructor({ length, buffer, leftToRightIndexing, littleEndianBits, } = {}) {
        if (length && buffer) {
            throw new Error('Only one of "length" or "buffer" must be given.');
        }
        if (length !== undefined) {
            assert.isPositiveInteger(length, 'length');
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            assert.isUint8Array(buffer, 'buffer');
        }
        // backwards compatibility for deprecated name `littleEndianBits`
        if (littleEndianBits !== undefined) {
            if (leftToRightIndexing !== undefined) {
                throw new Error('Using both "littleEndianBits" and "leftToRightIndexing" ' +
                    'is not allowed.');
            }
            assert.isBoolean(littleEndianBits, 'littleEndianBits');
            leftToRightIndexing = littleEndianBits;
        }
        if (leftToRightIndexing === undefined) {
            leftToRightIndexing = true;
        }
        else {
            assert.isBoolean(leftToRightIndexing, 'leftToRightIndexing');
        }
        if (length) {
            this.bits = new Uint8Array(Math.ceil(length / 8));
            this.length = length;
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.bits = new Uint8Array(buffer.buffer);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.length = buffer.length * 8;
        }
        this.leftToRightIndexing = leftToRightIndexing;
    }
    set(position, on) {
        assert.isNumber(position, 'position');
        assert.isBoolean(on, 'on');
        const { length, leftToRightIndexing } = this;
        const { index, bit } = _parsePosition(position, length, leftToRightIndexing);
        if (on) {
            this.bits[index] |= bit;
        }
        else {
            this.bits[index] &= 0xff ^ bit;
        }
    }
    get(position) {
        assert.isNumber(position, 'position');
        const { length, leftToRightIndexing } = this;
        const { index, bit } = _parsePosition(position, length, leftToRightIndexing);
        return !!(this.bits[index] & bit);
    }
    encodeBits() {
        return __awaiter(this, void 0, void 0, function* () {
            return jose_1.base64url.encode((0, pako_1.gzip)(this.bits));
        });
    }
    static decodeBits({ encoded }) {
        assert.isString(encoded, 'encoded');
        return (0, pako_1.ungzip)(jose_1.base64url.decode(encoded));
    }
    compressBits() {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, pako_1.gzip)(this.bits);
        });
    }
    static uncompressBits({ compressed }) {
        return __awaiter(this, void 0, void 0, function* () {
            assert.isUint8Array(compressed, 'compressed');
            return (0, pako_1.ungzip)(compressed);
        });
    }
}
exports.Bitstring = Bitstring;
function _parsePosition(position, length, leftToRightIndexing) {
    assert.isNonNegativeInteger(position, 'position');
    assert.isPositiveInteger(length, 'length');
    assert.isBoolean(leftToRightIndexing, 'leftToRightIndexing');
    if (position >= length) {
        throw new Error(`Position "${position}" is out of range "0-${length - 1}".`);
    }
    const index = Math.floor(position / 8);
    const rem = position % 8;
    const shift = leftToRightIndexing ? 7 - rem : rem;
    const bit = 1 << shift;
    return { index, bit };
}
