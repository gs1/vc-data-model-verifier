"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyTree = void 0;
const hexToBin_1 = require("./hexToBin");
const HASH_1 = require("./HASH");
const CONCAT_1 = require("./CONCAT");
const EQUAL_1 = require("./EQUAL");
const LSB_1 = require("./LSB");
// b.  Set merge_count to the lowest value (0 included) such that
// LSB(i >> merge_count) is not set, where LSB means the least
// significant bit.  In other words, set merge_count to the
// number of consecutive 1s found starting at the least
// significant bit of i.
const getMergeCount = (i) => {
    let merge_count = 0;
    while ((0, LSB_1.LSB)(i >> merge_count)) {
        merge_count++;
    }
    return merge_count;
};
const MERGE = (stack) => __awaiter(void 0, void 0, void 0, function* () {
    const prefix = (0, hexToBin_1.hexToBin)('01');
    const right = stack.pop();
    const left = stack.pop();
    stack.push(yield (0, HASH_1.HASH)((0, CONCAT_1.CONCAT)(prefix, (0, CONCAT_1.CONCAT)(left, right))));
});
const verifyTree = (root, entries) => __awaiter(void 0, void 0, void 0, function* () {
    const stack = [];
    const tree_size = entries.length;
    for (let i = 0; i < tree_size; i++) {
        const prefix = (0, hexToBin_1.hexToBin)('00');
        const entry = entries[i];
        // a.  Push HASH(0x00 || entries[i]) to stack.
        stack.push(yield (0, HASH_1.HASH)((0, CONCAT_1.CONCAT)(prefix, entry)));
        const merge_count = getMergeCount(i);
        // console.log({merge_count})
        for (let k = 0; k < merge_count; k++) {
            yield MERGE(stack);
        }
    }
    while (stack.length > 1) {
        yield MERGE(stack);
    }
    const computedRoot = stack[0];
    const expectedRoot = root;
    return (0, EQUAL_1.EQUAL)(computedRoot, expectedRoot);
});
exports.verifyTree = verifyTree;
