"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PROOF = void 0;
const MTH_1 = require("./MTH");
const CUT_1 = require("./CUT");
const highestPowerOf2LessThanN_1 = require("./highestPowerOf2LessThanN");
const SUBPROOF = (m, D_n, b) => __awaiter(void 0, void 0, void 0, function* () {
    const n = D_n.length;
    if (m === n) {
        return [yield (0, MTH_1.MTH)(D_n)];
    }
    if (m < n) {
        const k = (0, highestPowerOf2LessThanN_1.highestPowerOf2LessThanN)(n);
        // If m <= k, the right subtree entries D[k:n] only exist in the current tree.
        if (m <= k) {
            // We prove that the left subtree entries D[0:k] are consistent
            // and add a commitment to D[k:n]:
            // SUBPROOF(m, D_n, b) = SUBPROOF(m, D[0:k], b) : MTH(D[k:n])
            const left = (0, CUT_1.CUT)(D_n, 0, k);
            const first = yield SUBPROOF(m, left, b);
            const second = yield (0, MTH_1.MTH)((0, CUT_1.CUT)(D_n, k, n));
            return first.concat(second);
        }
        else if (m > k) {
            // If m > k, the left subtree entries D[0:k] are identical in both
            // trees.  We prove that the right subtree entries D[k:n] are consistent
            // and add a commitment to D[0:k]:
            const right = (0, CUT_1.CUT)(D_n, k, n);
            const first = yield SUBPROOF(m - k, right, false);
            const second = yield (0, MTH_1.MTH)((0, CUT_1.CUT)(D_n, 0, k));
            return first.concat(second);
        }
    }
    throw new Error('m cannot be greater than n');
});
// TODO: consistency_proof_v2
const PROOF = (m, D_n) => __awaiter(void 0, void 0, void 0, function* () {
    return SUBPROOF(m, D_n, true);
});
exports.PROOF = PROOF;
