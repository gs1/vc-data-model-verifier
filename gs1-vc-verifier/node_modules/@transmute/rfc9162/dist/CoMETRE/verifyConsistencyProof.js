"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyConsistencyProof = void 0;
const HASH_1 = require("../RFC9162/HASH");
const CONCAT_1 = require("../RFC9162/CONCAT");
const hexToBin_1 = require("../RFC9162/hexToBin");
const LSB_1 = require("../RFC9162/LSB");
const EQUAL_1 = require("../RFC9162/EQUAL");
const prefix = (0, hexToBin_1.hexToBin)('01');
const EXACT_POWER_OF_2_1 = require("../RFC9162/EXACT_POWER_OF_2");
const verifyConsistencyProof = (first_tree_root, first_tree_size, second_tree_root, second_tree_size, proof) => __awaiter(void 0, void 0, void 0, function* () {
    const { consistency_path } = proof;
    // 1.  If consistency_path is an empty array, stop and fail the proof verification.
    if (consistency_path.length === 0) {
        return false;
    }
    // 2.  If first is an exact power of 2, then prepend first_hash to the consistency_path array.
    if ((0, EXACT_POWER_OF_2_1.EXACT_POWER_OF_2)(first_tree_size)) {
        // hmm erata?
        // consistency_proof_v2.unshift(first_tree_root)
    }
    let fn = first_tree_size - 1;
    let sn = second_tree_size - 1;
    // 4.  If LSB(fn) is set, then right-shift both fn and sn equally until LSB(fn) is not set.
    while ((0, LSB_1.LSB)(fn)) {
        fn = fn >> 1;
        sn = sn >> 1;
    }
    // Set both fr and sr to the first value in the consistency_path array.
    let fr = consistency_path[0];
    let sr = consistency_path[0];
    // 6.  For each subsequent value c in the consistency_path array:
    for (let i = 1; i < consistency_path.length; i++) {
        const c = consistency_path[i];
        // a.  If sn is 0, then stop the iteration and fail the proof
        //        verification.
        if (sn === 0) {
            return false;
        }
        // If LSB(fn) is set, or if fn is equal to sn, then:
        if ((0, LSB_1.LSB)(fn) || fn === sn) {
            // i.    Set fr to HASH(0x01 || c || fr).
            fr = yield (0, HASH_1.HASH)((0, CONCAT_1.CONCAT)(prefix, (0, CONCAT_1.CONCAT)(c, fr)));
            // ii.   Set sr to HASH(0x01 || c || sr).
            sr = yield (0, HASH_1.HASH)((0, CONCAT_1.CONCAT)(prefix, (0, CONCAT_1.CONCAT)(c, sr)));
            // iii.  If LSB(fn) is not set, then right-shift both fn and sn
            //            equally until either LSB(fn) is set or fn is 0.
            while (!(0, LSB_1.LSB)(fn) && fn !== 0) {
                fn = fn >> 1;
                sn = sn >> 1;
            }
        }
        else {
            // Otherwise:
            // i.  Set sr to HASH(0x01 || sr || c).
            sr = yield (0, HASH_1.HASH)((0, CONCAT_1.CONCAT)(prefix, (0, CONCAT_1.CONCAT)(sr, c)));
        }
        fn = fn >> 1;
        sn = sn >> 1;
    }
    const sn_is_zero = sn === 0;
    if (!sn_is_zero) {
        throw new Error('sn is not zero, proof validation failed.');
    }
    const fr_is_first_hash = (0, EQUAL_1.EQUAL)(fr, first_tree_root);
    const sr_is_second_hash = (0, EQUAL_1.EQUAL)(sr, second_tree_root);
    return fr_is_first_hash && sr_is_second_hash;
});
exports.verifyConsistencyProof = verifyConsistencyProof;
