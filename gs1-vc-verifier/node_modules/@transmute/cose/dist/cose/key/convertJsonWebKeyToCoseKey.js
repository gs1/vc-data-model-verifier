"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertJsonWebKeyToCoseKey = void 0;
const jose_1 = require("jose");
const cbor_1 = require("../../cbor");
const key_common_parameters_1 = require("../key-common-parameters");
const key_type_parameters_1 = require("../key-type-parameters");
const key_type_1 = require("../key-type");
const elliptic_curves_1 = require("../elliptic-curves");
const iana_1 = require("../../iana");
const commonParams = Object.values(key_common_parameters_1.IANACOSEKeyCommonParameters);
const keyTypeParams = Object.values(key_type_parameters_1.IANACOSEKeyTypeParameters);
const keyTypes = Object.values(key_type_1.IANACOSEKeyTypes);
const curves = Object.values(elliptic_curves_1.IANACOSEEllipticCurves);
const keyTypeParamsByKty = {
    'OKP': keyTypeParams.filter((p) => p['Key Type'] === '1'),
    'EC2': keyTypeParams.filter((p) => p['Key Type'] === '2')
};
const getKeyTypeSpecificLabel = (keyType, keyTypeParam) => {
    let label = keyTypeParam;
    let foundKeyTypeParam = keyTypeParamsByKty[keyType].find((param) => {
        return param.Name === keyTypeParam;
    });
    if (!foundKeyTypeParam) {
        foundKeyTypeParam = keyTypeParamsByKty[keyType].find((param) => {
            return param.Name === keyTypeParam;
        });
    }
    if (foundKeyTypeParam) {
        label = parseInt(foundKeyTypeParam.Label, 10);
    }
    else {
        throw new Error(`Unable to find a label for this param (${keyTypeParam}) for the given key type ${keyType}`);
    }
    return label;
};
const convertJsonWebKeyToCoseKey = (jwk) => __awaiter(void 0, void 0, void 0, function* () {
    const { kty } = jwk;
    let coseKty = `${kty}`; // evidence of terrible design.
    if (coseKty === 'EC') {
        coseKty = 'EC2';
    }
    if (!keyTypeParamsByKty[coseKty]) {
        throw new Error('Unsupported key type');
    }
    const coseKey = new Map();
    for (const [key, value] of Object.entries(jwk)) {
        const foundCommonParam = commonParams.find((param) => {
            return param.Name === key;
        });
        let label = key;
        if (foundCommonParam) {
            label = parseInt(foundCommonParam.Label, 10);
        }
        switch (key) {
            case 'kty': {
                const foundKeyType = keyTypes.find((param) => {
                    return param.Name === coseKty;
                });
                if (foundKeyType) {
                    coseKey.set(label, parseInt(foundKeyType.Value, 10));
                }
                else {
                    throw new Error('Unsupported key type: ' + value);
                }
                break;
            }
            case 'kid': {
                if (foundCommonParam) {
                    coseKey.set(label, value);
                }
                else {
                    throw new Error('Expected common parameter was not found in iana registry.');
                }
                break;
            }
            case 'alg': {
                if (foundCommonParam) {
                    const foundAlgorithm = iana_1.iana['COSE Algorithms'].getByName(value);
                    if (foundAlgorithm) {
                        coseKey.set(label, parseInt(foundAlgorithm.Value, 10));
                    }
                    else {
                        throw new Error('Expected algorithm was not found in iana registry.');
                    }
                }
                else {
                    throw new Error('Expected common parameter was not found in iana registry.');
                }
                break;
            }
            case 'crv': {
                label = getKeyTypeSpecificLabel(coseKty, 'crv');
                const foundCurve = curves.find((param) => {
                    return param.Name === value;
                });
                if (foundCurve) {
                    coseKey.set(label, parseInt(foundCurve.Value, 10));
                }
                else {
                    throw new Error('Expected curve was not found in iana registry.');
                }
                break;
            }
            case 'x':
            case 'y':
            case 'd': {
                label = getKeyTypeSpecificLabel(coseKty, key);
                coseKey.set(label, (0, cbor_1.toArrayBuffer)(jose_1.base64url.decode(value)));
                break;
            }
            case 'x5c': {
                const items = (value || []).map((item) => {
                    return (0, cbor_1.toArrayBuffer)(jose_1.base64url.decode(item));
                });
                coseKey.set(label, items);
                break;
            }
            case 'x5t#S256': {
                coseKey.set(label, (0, cbor_1.toArrayBuffer)(jose_1.base64url.decode(value)));
                break;
            }
            default: {
                // by default we assume a text label
                coseKey.set(label, value);
            }
        }
    }
    // TODO: Length checks on x, y, d
    return coseKey;
});
exports.convertJsonWebKeyToCoseKey = convertJsonWebKeyToCoseKey;
